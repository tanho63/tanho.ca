---
layout: single
title: "Advent of Code, Day 9"
date:   2020-12-09
summary: "Tackling day nine of Advent of Code - encoding error!"
type: rshiny
menu:
  sidebar:
    name: AdventofCode-09
    identifier: adventcode2020-9
    parent: rshiny
url: /adventcode-2020-09
hero: /images/rshiny/advent.jpg
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>Day nine - encoding error!</p>
<pre class="r"><code>library(tidyverse)
library(here)

knitr::opts_chunk$set(echo = TRUE)</code></pre>
<p>— Description —</p>
<blockquote>
<p>XMAS starts by transmitting a preamble of 25 numbers. After that, each number you receive should be the sum of any two of the 25 immediately previous numbers. The two numbers will have different values, and there might be more than one such pair.</p>
<p>For example, suppose your preamble consists of the numbers 1 through 25 in a random order. To be valid, the next number must be the sum of two of those numbers.</p>
<p>The first step of attacking the weakness in the XMAS data is to find the first number in the list (after the preamble) which is not the sum of two of the 25 numbers before it. What is the first number that does not have this property?</p>
</blockquote>
<p>— Data —</p>
<pre class="r"><code>input_09 &lt;- read_lines(&quot;https://github.com/tanho63/advent_of_code/raw/master/2020/day-09.txt&quot;)</code></pre>
<p>— Cleaning —</p>
<p>Offhand, I’m going to use Davis Vaughan’s “slider” package to create the rolling windows for each row, and hopefully that helps tackle each problem.</p>
<pre class="r"><code>library(slider)

df_cipher &lt;- tibble(num = input_09) %&gt;% 
  mutate_all(as.numeric) %&gt;% 
  mutate(rolling = slide(num,~.x,.before = 24, .complete = TRUE) %&gt;% lag()) %&gt;% 
  slice(-(1:25))</code></pre>
<pre class="r"><code>head(df_cipher)</code></pre>
<pre><code>## # A tibble: 6 x 2
##     num rolling   
##   &lt;dbl&gt; &lt;list&gt;    
## 1    30 &lt;dbl [25]&gt;
## 2    11 &lt;dbl [25]&gt;
## 3     3 &lt;dbl [25]&gt;
## 4    33 &lt;dbl [25]&gt;
## 5    78 &lt;dbl [25]&gt;
## 6     4 &lt;dbl [25]&gt;</code></pre>
<p>— Problem 1 —</p>
<blockquote>
<p>Find the first number which is not the sum of the two numbers before it.</p>
</blockquote>
<pre class="r"><code>problem_1 &lt;- df_cipher %&gt;% 
  mutate(rolling_sum = map2_lgl(rolling,num, 
                       ~ crossing(x = .x, y = .x) %&gt;% 
                          mutate(sum = x + y,
                                 flag = sum == .y) %&gt;% 
                         summarise(flag = any(flag)) %&gt;% 
                         pull(flag)))</code></pre>
<pre class="r"><code>problem_1 %&gt;% 
  filter(!rolling_sum)</code></pre>
<pre><code>## # A tibble: 1 x 3
##        num rolling    rolling_sum
##      &lt;dbl&gt; &lt;list&gt;     &lt;lgl&gt;      
## 1 10884537 &lt;dbl [25]&gt; FALSE</code></pre>
<pre class="r"><code>solution_1 &lt;- problem_1 %&gt;% 
  filter(!rolling_sum) %&gt;% 
  pull(num)</code></pre>
<p>— Problem 2 —</p>
<blockquote>
<p>The final step in breaking the XMAS encryption relies on the invalid number you just found: you must find a contiguous set of at least two numbers in your list which sum to the invalid number from step 1.</p>
</blockquote>
<p>Back to slider again, this time using a loop to iterate the size of the rolling window upward until the solution is found.</p>
<pre class="r"><code>problem_2 &lt;- df_cipher %&gt;% 
  filter(num &lt; solution_1) %&gt;%
  select(num)

success &lt;- FALSE
size &lt;- 1

while(!success){
  size &lt;- size + 1
  
  test_solve &lt;- problem_2 %&gt;% 
    mutate(rolling_sum = slide_dbl(num,sum,.complete = TRUE,.before = size - 1),
           success = rolling_sum == solution_1)
  
  success &lt;- any(test_solve$success,na.rm = TRUE)
}

cleanup_solution &lt;- test_solve %&gt;% 
  slice((which(test_solve$success)-size+1):which(test_solve$success))</code></pre>
<pre class="r"><code>cleanup_solution</code></pre>
<pre><code>## # A tibble: 17 x 3
##       num rolling_sum success
##     &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;  
##  1 408514     6419520 FALSE  
##  2 507208     6675531 FALSE  
##  3 753282     7148649 FALSE  
##  4 695857     7429404 FALSE  
##  5 570543     7628429 FALSE  
##  6 444281     7753756 FALSE  
##  7 626571     7967090 FALSE  
##  8 592643     8216758 FALSE  
##  9 500865     8374124 FALSE  
## 10 693401     8676795 FALSE  
## 11 599118     8899534 FALSE  
## 12 661929     9061257 FALSE  
## 13 814643     9507096 FALSE  
## 14 662453     9792646 FALSE  
## 15 712303    10107548 FALSE  
## 16 852795    10517218 FALSE  
## 17 788131    10884537 TRUE</code></pre>
<pre class="r"><code>min(cleanup_solution$num) + max(cleanup_solution$num)</code></pre>
<pre><code>## [1] 1261309</code></pre>
